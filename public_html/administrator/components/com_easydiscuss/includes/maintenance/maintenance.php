<?php
/**
* @package		EasyDiscuss
* @copyright	Copyright (C) 2010 - 2015 Stack Ideas Sdn Bhd. All rights reserved.
* @license		GNU/GPL, see LICENSE.php
* EasyBlog is free software. This version may have been modified pursuant
* to the GNU General Public License, and as distributed it includes or
* is derivative of works licensed under the GNU General Public License or
* other free or open source software licenses.
* See COPYRIGHT.php for copyright notices and details.
*/
defined('_JEXEC') or die('Unauthorized Access');

class EasyDiscussMaintenance extends EasyDiscuss
{
	public $nullDate = '';
	public $nowDate = '';
	public $hasRan = false;
	public $error;

	public function __construct()
	{
		// Initiate some expensive functions and store them in class variable
		$db = ED::db();

		$this->nullDate = method_exists($db, 'getNullDate') ? $db->getNullDate() : '0000-00-00 00:00:00';
		$this->nullDate = $db->Quote($this->nullDate);

		// Get the current date
		$date = ED::date();

		// Set the current date
		$this->nowDate = $db->quote($date->toSql());
	}


	/**
	 * Get the available scripts and returns the script object in an array
	 *
	 * @since  4.0
	 * @access public
	 */
	public function getScripts($from = null)
	{
		$files = $this->getScriptFiles($from);

		$result = array();

		foreach ($files as $file) {
			$classname = $this->getScriptClassName($file);

			if ($classname === false) {
				continue;
			}

			$class = new $classname;

			$result[] = $class;
		}

		return $result;
	}

	/**
	 * Get the available script files and return the file path in an array
	 *
	 * @since  4.0
	 * @access public
	 */
	public function getScriptFiles($from = null, $operator = '>')
	{
		$files = array();

		// If from is empty, means it is a new installation, and new installation we do not want maintenance to run
		// Explicitly changed backend maintenance to pass in 'all' to get all the scripts instead.
		if (empty($from)) {
			return $files;
		}

		if ($from === 'all') {

			$phpFiles = JFolder::files(DISCUSS_ADMIN_UPDATES, '.php$', true, true);

			if ($phpFiles) {
				$files = array_merge($files, $phpFiles);
			}

		} else {
			$folders = JFolder::folders(DISCUSS_ADMIN_UPDATES);

			if (!empty($folders)) {
				foreach ($folders as $folder) {
					// We don't want things from "manual" folder
					if ($folder === 'manual') {
						continue;
					}

					// We cannot do $folder > $from because '1.2.8' > '1.2.15' is TRUE
					// We want > $from by default, NOT >= $from, unless manually specified through $operator
					if (version_compare($folder, $from, $operator)) {
						$fullpath = DISCUSS_ADMIN_UPDATES . '/' . $folder;

						$files = array_merge($files, JFolder::files($fullpath, '.php$', false, true));
					}
				}
			}
		}

		return $files;
	}

	/**
	 * Get the script class name
	 *
	 * @since  4.0
	 * @access public
	 */
	public function getScriptClassName($file)
	{
		static $classnames = array();

		if (!isset($classnames[$file]))
		{
			if (!JFile::exists($file))
			{
				$this->setError('Script file not found: ' . $file);
				$classnames[$file] = false;
				return false;
			}

			require_once($file);

			$filename = basename($file, '.php');

			$classname = 'EasyDiscussMaintenanceScript' . $filename;

			if (!class_exists($classname)) {
				$this->setError('Class not found: ' . $classname);
				$classnames[$file] = false;
				return false;
			}

			$classnames[$file] = $classname;
		}

		return $classnames[$file];
	}


	/**
	 * Wrapper function to execute the script
	 *
	 * @since  4.0
	 * @access public
	 */
	public function runScript($file)
	{
		$class = null;

		if (is_string($file)) {
			$classname = $this->getScriptClassName($file);

			if ($classname === false) {
				return false;
			}

			$class = new $classname;
		}

		if (is_object($file)) {
			$class = $file;
		}

		if (!$class instanceof EasyDiscussMaintenanceScript) {
			$this->setError('Class ' . $classname . ' is not an instance of EasyDiscussMaintenanceScript');
			return false;
		}

		$state = true;

		// Clear the error
		$this->error = null;

		try {
			$state = $class->main();
		} catch (Exception $e) {
			$this->setError($e->getMessage());
			return false;
		}

		if (!$state) {
			if ($class->hasError()) {
				$this->setError($class->getError());
			}

			return false;
		}

		return true;
	}

	/**
	 * Get the script title
	 *
	 * @since  4.0
	 * @access public
	 */
	public function getScriptTitle($file)
	{
		$classname = $this->getScriptClassName($file);

		if ($classname === false) {
			return false;
		}

		$vars = get_class_vars($classname);
		return JText::_($vars['title']);
	}

	/**
	 * Get the script description
	 *
	 * @since  4.0
	 * @access public
	 */
	public function getScriptDescription($file)
	{
		$classname = $this->getScriptClassName($file);

		if ($classname === false) {
			return false;
		}

		$vars = get_class_vars($classname);
		return JText::_($vars['description']);
	}

	/**
	 * Checks if there are any error generated by executing the script
	 *
	 * @since  4.0
	 * @access public
	 */
	public function hasError()
	{
		return !empty($this->error);
	}

	/**
	 * To prune the notifications
	 *
	 * @since	3.0
	 * @access	public
	 */
	public function pruneNotifications()
	{
		$db = ED::db();
		$date = ED::date();

		$config = ED::config();
		$days = $config->get('notifications_history', 30);
		$limit = $config->get('prune_notifications_limit', 100);

		$query = [];

		$query[] = 'DELETE FROM ' . $db->nameQuote('#__discuss_notifications');
		$query[] = 'WHERE ' . $db->nameQuote('created') . ' <= DATE_SUB(' . $db->Quote($date->toSql()) . ' , INTERVAL ' . $days . ' DAY )';
		if ($limit) {
			$query[] = 'LIMIT ' . $limit;
		}

		$query = implode(' ', $query);
		$db->setQuery($query);

		$db->query();

		return true;
	}

	public function run()
	{
		if ($this->hasRan) {
			return;
		}

		// 1. Lock new post (with proper lockdate)
		// 2. Lock older post (without lockdate)
		//     2.1. First fill empty lock date for posts with replies
		//         2.1.1. Find empty lock date
		//         2.1.2. Update emtpy lock date
		//         2.1.3. Lock expired posts
		//     2.2. Lastly fill empty lock date for posts without replies
		//         2.2.1. repeat sub-steps in 2.1
		//     2.3. Lock all expired posts.

		$config = ED::config();

		$userLastRepliedInterval = (int) $config->get('main_daystolock_afterlastreplied');
		$userPostCreatedInterval = (int) $config->get('main_daystolock_aftercreated');

		// if both is zero. this also means the auto lock feature is not required.
		if (empty($userLastRepliedInterval) && empty($userPostCreatedInterval)) {
			return;
		}

		if ($userLastRepliedInterval || $userPostCreatedInterval) {
			$this->lock();
			$this->hasRan = true;
		}

		if ($config->get('main_lock_newpost_only')) {
			return;
		}

		if ($userLastRepliedInterval > 0) {
			$db = ED::db();
			$query = 'UPDATE `#__discuss_thread` SET lockdate = DATE_ADD(replied, INTERVAL ' . $userLastRepliedInterval . ' DAY)'
					. ' WHERE islock = 0 AND published = 1 AND num_replies > 0'
					. ' AND lockdate = ' . $this->nullDate;

			$db->setQuery($query);
			$db->query();
		}

		if ($userPostCreatedInterval > 0) {
			$db = ED::db();
			$query = 'UPDATE `#__discuss_thread` SET lockdate = DATE_ADD(created, INTERVAL ' . $userPostCreatedInterval . ' DAY)'
					. ' WHERE islock = 0 AND published = 1'
					. ' AND lockdate = ' . $this->nullDate;

			$db->setQuery($query);
			$db->query();
		}

		$this->lock();
	}

	public function lock()
	{
		$db = ED::db();
		$query = 'UPDATE `#__discuss_thread` SET `islock` = 1'
				. ' WHERE `islock` = 0'
				. ' AND `published` = 1'
				// lockdate != 0000-00-00 00:00:00 AND lockdate <= now()
				. ' AND `lockdate` != ' . $this->nullDate
				. ' AND `lockdate` <= ' . $this->nowDate;
		$db->setQuery($query);
		$db->query();
	}
}
